面试官您好，很高兴能够参加今天的面试，我叫王亮，本科在南昌航空大学就读，我读的专业是软件工程，本科主要学的是JAVA语言，对python也比较感兴趣，本科期间在老师的实验室参与过一些项目开发，然后也参与过像蓝桥杯小程序这样的竞赛，课外的话参与组织过学校的摄影大赛

#### Java基础

- Java程序初始化顺序：父类的静态代码块—子类的静态代码块—父类的普通代码块—父类的构造方法—子类的普通代码块
- +=会自动强转（自动装箱功能），但是+必须要手动强转b=(byte)(a+b)
- final类不能用来派生子类，因为用`final`修饰的类不能被继承
- 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问
- 两个对象`hashCode`相同，但这两个对象不一定相等（哈希碰撞）
- 对象存在于堆内存，局部变量则存在于栈内存
- 重载：方法名相同参数不同， 重写：继承中使用
- Object 类的方法：`getClass()`、 `hashCode()`、`clone()`、`toString()`等
- 反射机制用途：反编译、IDEA中自动跳出对象的方法属性、加载数据库驱动
- 异常：受检查异常如`IOException`、`ClassNotFoundException` 等；非受检查异常`RuntimeException`的子类如：`NullPointerException`
- 序列化：将对象转化为二进制字节流

  - `transient`关键字：用来禁止某个字段序列化，只能修饰变量
- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象
- 字符串常量池：对于编译期可以确定值的字符串，也就是常量字符串 ，`jvm` 会将其存入字符串常量池（堆中）
- 序列化主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中
- 关于`equals()`：对于引用类型来说，如果没有被重写，则是比较对象的地址是否相等，`String`中的`equals()`被重写 了比较的是地址的内容
- `HashSet` 如何检查重复：首先计算对象的`hashCode`，同时跟其它对象的`hashCode`比较，如果没有相等的则判断没有重复，否则调用`equals()`判断`hashCode`相等的对象是否真的相同
- `ArrayList`扩容机制：线程不安全，默认为10，每次扩容容量变为原来的1.5倍
- `HashMap`扩容机制：线程不安全，默认为16，每次扩容容量为原来的2倍
- `ConcurrentHashMap` ：线程安全
- 堆：存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
- `JVM`中对象创建的过程：
  
  - Step1：类加载检查，对一条new指令，检查能否在常量池中定位到类的符号引用是否被加载过，没有则执行相应的类加载过程（确定所需内存大小）
  - Step2：分配内存，在堆上分配内存
  - Step3：初始化零值
  - Step4：设置对象头，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码等信息
  - Step5：执行 `init` 方法，把对象按照程序员的意愿进行初始化
- 线程之间传递参数：？
- 调用`start()`方法可启动线程并进入就绪状态，直接执行`run()`方法不会以多线程方法执行
- 线程池：使用`ThreadPoolExecutor` 创建。`ThreadPoolExecutor`的三个重要参数：
  - `corePoolSize` ：核心线程数定义了最小可以同时运行的线程数量
  - `maximumPoolSize` ：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数
  - `workQueue`：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中
- 几种常见的线程池：`FixedThreadPool`：固定线程数量的线程池；`SingleThreadExecutor`：只有一个线程的线程池；`CachedThreadPool`：可根据实际情况调整线程数量的线程池
- 创建线程的三种方式：继承 `Thread`类、实现 `Runnable`接口、实现 `Callable`接口，其中`Runnable` 接口不会返回结果或抛出检查异常，但是 `Callable` 接口可以
- 项目中哪里用到了多线程：提交健康打卡
- B树和B+树：B树每个节点都存储key和data， B+树只有叶子节点存放 key 和 data







#### Redis

- `redis`常用数据结构：`string`；`list`；`hash`：存储对象数据；`set`：无序不重复；`bitmap`：常用来保存状态信息（比如是否点赞、是否登录）
- `redis`如何判断数据是否过期：`redis` 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间，是一个long long 类型的整数
- 过期数据的删除策略

  - 惰性删除：只会在取出 key 的时候才对数据进行过期检查，可能会造成太多过期 key 没有被删除，对 CPU 更加友好
  - 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作，对内存更加友好
- `redis`内存淘汰机制：淘汰最近最少使用的数据淘汰、挑选将要过期的数据淘汰、任意选择数据淘汰
- 缓存穿透：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上。解决方法：布隆过滤器
- 布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。





#### Scrapy

- 执行流程：引擎将要爬取的链接封装成`request`请求，交给`Scheduler`进行调度，然后交给下载器进行下载封装成`response`包，爬虫进行解析得到`Item` 数据，并交给管道进行处理
- 该项目不使用框架自带的管道处理数据，而是使用 `Redis` 管道





#### Spring基础

- `spring`启动过程：
  - 初始化容器：实例化`BeanFactory`工厂
  - 将配置类的`BeanDefinition`注册到容器中
  - 调用`refresh()`方法刷新容器

- `spring`事务：使用`@Transactional` 注解。相关属性：`isolation`事物隔离级别（默认可重复读）；`timeout`超时时间（自动回滚）；`readOnly`是否只读事务；`propagation`传播行为
- `bean`生命周期：
  - 实例化`bean`：反射的方式生成对象
  - 填充`bean`属性
  - 调用`aware`接口相关方法
  - 调用`BeanPostProcessor`中的前置处理方法，使用的较多的有`ApplicationContextPostProcessor`
  - 调用`intimethod`方法：`invokeIntimethod`(),判断是否实现了`intializingBean`接口，调用`afterPropertiesSet`方法，没有就不调用
  - 调用`BeanPostProcessor`的后置处理方法：`spring`的`aop`就是在此处实现的`
  - 获取完整的对象，可以通过`getBean`的方式获取对象
  - 销毁：`destoryMethod`()
- 谈谈Spring `Ioc`的理解，原理和实现
  - 控制反转，原来的对象有使用者来控制，有了Spring之后把整个对象交给Spring管理；
  - 容器，存储对象，使用map结构来存储，在Spring中一般存在三级缓存，`singletonObject`存放完整对象，整个bean的生命周期，从创建到销毁的过程都是由容器来管理
- `Bean` `Factory`与`FactoryBean`的区别
  - 相同点：都是用来创建bean对象的
  - 不同点：使用`BeanFactory`创建对象 时必须严格遵循生命周期流程，太复杂了，如果想要简单的自定义某个对象的创建，同时交给spring来管理，那么就必须实现`FactoryBean`接口，接口里的方法有：`isSingleton()`：是否是单例对象；`getObjectType()`：获取返回对象的类型；`getObject()`：自定义创建对象的过程
- Spring中的设计模式
  - 单例模式：bean默认是单例的
  - 原型模式：指定作用域为`prototype`
  - 工厂模式：`BeanFactory`
  - 模板方法：`postProcessBeanFactory`
  
- 用`mybatis`实现分页：先配置分页插件、`new Page()`对象









#### 人工智能基础

- 谈谈梯度下降：梯度下降用来最小化损失函数，沿着梯度方向，也就是下降速度最快的方向向下走一步。

- 有监督学习和无监督学习：有监督学习是对有标记的训练数据进行学习；无监督学习是对无标记的训练数据进行学习（如`Kmeans`)

- 线性回归

  - 回归问题

  - 假设函数：
    $$
    hθ(X)=θ0+θ1X1+θ2X2+θ3X3+...+θnXn
    $$
    

- 逻辑回归

  - 分类问题

  - 代价函数：
    $$
    g(z)=1/(1+e^−z)
    $$
    
    $$
    Cost(hθ(x),y)=−ylog(hθ(x))−(1−y)log(1−hθ(x))
    $$



- 支持向量机`SVM`
  - 尽可能用大的间距将样本区分开
  - 假设函数直接输出0和1：if (θT*x > 0)   hθ(x)=1 
  - 代价函数图像：
  - ![](C:\Users\WangLiang\Pictures\svm.PNG)
  - C表示正则化参数，值越大对异常点越敏感
  - 核函数：线性核函数、高斯核函数![](C:\Users\WangLiang\Pictures\核函数.PNG)
  
  
  
  - 关于如何选择标记点：可以把每个样本都当作一个标记点
  
  - 支持向量机利用核函数重新定义样本的特征，在假设函数中用f代替x
  
- `K-Means`算法：随机选取K个样本点作为聚类中心，计算各个样本到这K个聚类中心的距离并将其分到距离最小的聚类中心的类别中，对每个类别重新计算聚类中心（质心），重复下去

- 为什么要用激活函数：激活函数是非线性函数，如果使用线性函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合

- 为什么`LSTM`中存在`sigmoid`和`relu`两种激活函数：`sigmoid` 用在了各种`gate`上，产生0~1之间的值，`relu`用在了状态和输出上

- 过拟合：训练误差和测试误差之间的差距太大，模型在训练集上表现很好，但在测试集上却表现很差，模型对训练集"死记硬背"，没有理解数据背后的规律

- 欠拟合：模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律

- 循环神经网络：主要用来处理序列数据，它由输入层、一个隐藏层和一个输出层，通过权重建立了相邻时间步隐藏层之间的关系，缺点是无法处理很长的输入序列

- 长短期记忆网络：是一种特殊的`RNN`，比`RNN`多了三个门控单元：遗忘门、输入门、输出门，遗忘门就是对前面的时间步选择性的遗忘；输入门是对当前时间步的信息进行记忆；最后输出门就是决定哪些将会被当成当前时间步的输出。总之`LSTM`通过门控状态来控制传输状态，记住需要长时间记忆的，忘记不重要的信息

- 为什么使用LSTM：通过加入三个控空单元，实现学习并长期保存信息

- 简单描述一下LSTM：

- 关于回答数的分析与预测：回答数分析的研究对象为回答数趋于稳定的知乎问题，问题的回答数相差很大，有些只有个位数有些达到了几千个，同时回答数多的问题它的回答数趋于稳定的时间也就更长，所以根据问题回答数和回答数趋于稳定的时间进行分类，分好类之后分析问题的回答数在一个月、半年、一年内随时间的变化，得到变化曲线，定义函数进行拟合。通过研究曲线斜率的变化，得出拟合函数a − a/(1 + (b ∗ x)^c)，计算拟合的方差、均方差、均方根得到合适的参数。在回答数预测实验中，将回答数以数量级的方式人为的分为了 4 个区间，结合前面得到的拟合函数便可实现岁回答数变化的预测
  
- 遇到的一些问题，数据集不平衡，，对数据集进行文本增强，本文采用了 `kaggle` 比赛常用的一种方式：`TTA`，即将文本先翻译成英文，再将英文翻译回中文。







#### 密码学

- 基本加密思想：置换和移位

- 对称密钥算法（私有密钥算法）
  - 使用同一个密钥进行加密和解密
  - 缺点：密钥的分发、密钥存储和管理
  - 常用算法：`DES`、 `3DES`、 `AES`、`RC系列`
  - `DES`算法：首先进行`IP`置换并分为两部分各32位（置换规则如58->60、50->52）；再进行16轮的迭代置换（拓展置换、S盒替换、P盒替换）；最后进行初始逆置换得到密文数据
  - `3DES`算法：密钥长度放大三倍
  - `AES`(Advanced encryption Standard) ：可用于语音和视频加密
  
- 非称密钥算法（公有密钥算法）
  
  - A向B发送信息，A通过B公布的公钥进行加密，B使用自己的密钥进行解密
  - 使用两个密钥，公钥加密，私钥解密，公钥公开
  - 常用算法：`RSA`、`DH`、`DSA`、`ECC`
  - `RSA`：首先随机选择两个不等的质数计算乘积，乘积的二进制位数即密钥的位数；再计算乘积的欧拉函数值，随机选择一个小于欧拉函数且互为质数的整数e，计算e和乘积的模反元素d；将e和乘积封装成公钥，d和乘积封装成私钥
  
- 数字签名![](C:\Users\WangLiang\Pictures\数字签名.PNG)

  

- 数字证书：证明公钥是属于某个人的

- 摘要算法：`MD5`、`SHA`







#### 操作系统

- 单道批处理系统到多道批处理系统的转换需要什么硬件支持：中断机构

- 什么是系统调用：操作系统提供给用户程序的接口，当程序需要访问系统资源时，通过系统调用想操作系统发出请求
- 就绪态到运行态：进程调度；运行态到就绪态：时间片用完；运行态到阻塞态：IO请求；阻塞态到就绪态：IO完成
- 管程：实现进程同步，包括：管程名称、共享数据、对数据操作的一组过程、初始化代码
- 哲学家问题的解决方法：最多允许四位哲学家同时拿左边的筷子、当哲学家的左右筷子都可用时才允许拿起筷子进餐、规定奇数号的哲学家先拿左边的筷子再拿右边的筷子，偶数号哲学家相反
- 进程的通信：共享存储、管道通信、消息队列、共享内存
- 进程调度算法：先到先服务、短作业优先、时间片轮转、多级反馈队列、优先级调度、高响应比调度
- 死锁产生的必要条件：资源互斥、不可剥夺、请求并保持、循环等待
- 死锁处理策略：预防死锁（破坏必要条件）、避免死锁（银行家算法）、检测解除死锁
- 程序运行过程：编译、链接、装入内存
- 可重定位装入方式：就是把装入模块种的逻辑地址转化为内存中的物理地址，逻辑地址与程序在内存中的起始地址相加
- 内存管理方式：
  - 连续分配：单一连续分配、固定分区分配、动态分区分配
  - 非连续分配管理方式：基本分页、基本分段、段页式
- 快表：提高虚拟地址到物理地址的转换速度
- 多级页表：页表过大且占用连续内存空间，实现离散分配，仅将需要的部分页表调入内存
- 时间局部性：一条指令或数据被访问后，不久之后会被再次访问
- 空间局部性：某个存储单元被访问后，它附近的存储单元也将被访问
- 虚拟内存：使得应用程序认为它拥有连续的可用的内存
- 请求分页地址变换过程：先查询快表，若不在快表中则查询页表，若在内存中则修改快表并形成物理地址，若不在内存则发生缺页，访问外存，若内存满了则换出一页，将缺失的页存入内存，修改快表并形成物理地址
- 缺页中断：页面不在内存中，可能需要的操作：修改页表、分配页框
- 页面置换算法：最佳置换、先进先出、最近最久未使用、时钟置换
- 抖动：刚换出的页面又换入内存，分配的物理页帧数不足
- `IO`控制方式：
  - 程序直接控制方式：CPU会一直不断的轮询检查设备的状态
  - 中断驱动方式：I/O操作开始之前、完成之后需要需要CPU介入，等待I/O完成的过程中CPU可以切换到别的进程执行
  - `DMA`方式：在IO设备和内存之间开辟数据交换通路
  - 通道控制方式：低配版的CPU
- SPOOLING技术：缓解CPU和IO的速度差异
- 外中断：由外部设备引起的
- 内中断（陷入）：由CPU内部引起，如地址越界运算溢出



#### 数据结构

- B树和B+树的区别：B树中每个节点都存储数据，B+树的数据存储在叶节点中且叶节点通过指针连接，非叶节点起索引作用
- B树
  - 插入 ：找到插入的节点，插入之后检查是否溢出，若溢出则进行分裂
  - 删除：分兄弟节点够借和不够借
- 最小生成树算法：
  - `Prim`算法：每次选择与当前顶点集合最近的顶点
  - `Kruskal`算法：每次选择权值最小的边构成最小生成树
- 最小生成树中的“最小”是什么意思：生成树中各边的权值最小
- 生成树：包含连通图的所有顶点，若砍去一条边则会变成非连通图，增加一条边则会产生回路
- 二叉树和度为2的树的区别：第一二叉树区分左右子树，度为2的树是指每个节点最多两颗子树可能没有子树
- 最短路径：`Dijkstra`算法、`Floyd`算法
- 树的存储结构：
  - 双亲表示法：用数组存储节点，每个节点设置一个指针，指向双亲节点在数组中的位置
  - 孩子表示法：每个节点的孩子节点用链表链接起来
  - 孩子兄弟表示法：二叉链表，每个节点包括节点值、指向第一个孩子节点的指针、指向节点下一个兄弟节点的指针
- 平衡二叉树是二叉排序树
- 散列表：根据关键字直接进行存储，建立了关键字和存储地址之间的映射
- 解决哈希冲突：开放地址法、拉链法
- 插入排序
  - 直接插入排序：适用于基本有序的元素
  - 折半插入排序减少了比较元素的次数
  - 希尔排序：不稳定
- 交换排序
  - 冒泡排序：稳定，每次确定一个位置
  - 快速排序：不稳定，每次选定一个枢轴元素，经过一趟排序分成两部分，左边一部分小于枢轴元素，右边一部分大于数周元素，再对两部分元素重复操作
- 选择排序
  - 堆排序：首先将元素建成一个初始堆，调整成大小顶堆，输出堆顶元素，再进行调整建堆，重复操作
- 归并排序：以2路归并为例，首先把n个元素看作n个有序的子表，两两归并，得到n/2个长度未2或1的有序表，继续两两归并
- Top(k)问题：先读取K个元素，建立小顶堆，将剩余的元素依次与堆顶比较，如果小于或等于堆顶则比较下一个，否则删除堆顶，将新数据插入堆中重新调整成小顶堆，最后堆中的K个元素即为所求





#### 计算机网络

- 应用层

  - 协议：`HTTP`、`FTP`、`SMTP`

- 传输层

  - 协议：`TCP`、`UDP`

  - 三次握手：首先客户端向服务端发送请求报文把`SYN`字段设为1，服务端收到报文后向客户端发送确认报文并且`SYN`和``ACK`设为1，客户端收到确认报文后向服务端也发送一个确认报文`ACK`设为1

  - 四次挥手：首先客户端发出连接释放报文`FIN`置为1；服务端接收到报文后发出确认报文置`ACK`为1；服务端向客户端发送连接释放报文置`FIN`为1；客户端发送确认报文置`ACK`为1

  - 为什么客户端最后还要等待`2MSL`：确保客户端的确认报文能够到达服务器，如果服务端 没有收到会重新发送

  - TCP拥塞控制：

    - 接受窗口：接受方的容量

    - 拥塞窗口：发送方根据拥塞程度而设置的窗口

    - 发送窗口 = min{接受窗口，拥塞窗口}

    - 慢开始：每经过一个传输轮次拥塞窗口加倍

    - 拥塞避免：拥塞窗口缓慢增加

    - 快重传：发送方收到三个重复`ACK`报文直接重传对方未收到的报文，不必等待重传计时器超时

    - 快恢复：慢开始门限设置为当前拥塞窗口的一半

    - ![](C:\Users\WangLiang\Pictures\拥塞控制.jpg)

      
    
    - `SYN`攻击：攻击者在短时间内伪造大量不存在`IP`地址，向服务器不断发送SYN包，导致服务器不断重发直至超时

- 网络层

  - 协议：`ARP`、`ICMP`、`OSPF`、	`BGP`
  - `NAT`地址转换：将专用网络地址转换为公用网络地址
  - `ARP`协议：`IP`地址到`MAC`地址的映射，先查询高速缓存，若不存在则发送`ARP`广播请求，目的主机（`IP`地址相同）发送`ARP`响应（自己的`MAC`地址）
  - `ICMP`差错报告报文
  - `IPv4`和`IPv6`的区别：`IPv6`地址空间更大、安全性、灵活的首部格式

- 数据链路层

  - 多帧滑动窗口与后退N帧协议`GBN`
  - 多帧滑动窗口与选择重传协议`SR`
  - 介质访问控制：`CSMA/CD`、`CSMA/CA`协议

- 输入一个网址到返回内容的过程：

  - 浏览器查询域名的`IP`地址（`DNS`）
  - 浏览器与服务器建立`TCP`连接
  - 浏览器发出`HTTP`请求
  - 服务器响应请求，把数据发送给客户端
  - TCP连接释放
  
- `IP`地址分为哪些部分：头部和数据，头部包括总长度、标志、偏移、校验和、原`IP`地址和目的`IP`地址

- MAC地址与`IP`地址的区别：

  - `MAC`地址工作在链路层及以下，`IP`地址工作在网络层及以上
  - 长度不同。`IP`地址为32位，`MAC`地址为48位
  - `IP`地址的分配是基于我们自身定义的网络拓扑，`MAC`地址的分配是基于制造商

- 网络的时延包括什么：

  - 排队时延
  - 发送时延：将数据从设备中发送到链路上的时间
  - 传播时延：链路上传播花费的时间







#### 数据库

- 概念模型
- 关系的完整性：
  - 实体完整性：主键不为空且唯一
  - 参照完整性：对外键的约束
  - 用户定义的完整性：如值不为空、唯一、性别字段只能取“男女”等
- 部分函数依赖：学号+身份证—>姓名，去掉学号和身份证也能推出姓名
- 传递函数依赖：学号—>学院，学院—>名字，学号—>名字
- 包含在候选码中的属性属于主属性
- 三大范式
  - 第一范式：属性不可再分
  - 第二范式：消除非主属性对码的部分函数依赖，一张表只保存一种数据，比如学生表里不能有课程信息
  - 第三范式：消除非主属性对码的传递函数依赖，表中每列数据都和主键直接相关，设置外键
  - BC范式：消除属性对码的部分和传递函数依赖
- 数据库设计
  - 需求分析
  - 概念结构设计：E-R图
  - 逻辑结构设计：E-R图转化为关系模型
  - 物理结构设计：逻辑模型转化为物理模型
  - 运行维护
- ER图转换为关系模式的原则：
  - 实体间联系是一对一：在两个实体中任选一个，添加另一个实体的主键即可
  - 一对多：在多的一端添加另一端的主键
  - 多对多：生成一个新的关系模式
- 事务的特性：
  - 原子性：不可分割，要么都执行否则都不执行
  - 一致性：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的
  - 隔离性：各事务之间相互独立不影响
  - 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的
- 并发事务带来的问题：
  - 脏读：一个事务修改了数据但未提交，另一个事务访问了这个脏数据
  - 丢失修改：两个事务同时修改一个数据，其中一个事务的修改无效
  - 不可重复读：一个事务多次读取同一数据，在两次读取之间另一个事务修改了数据，导致两次结果不一样，强调修改
  - 幻读：一个事务读取了几行数据，另一个事务插入了一些数据，再次查询多出一些数据，强调新增或删除
- 数据库如何实现`ACID`：
  - 原子性：利用`Innodb`的`undo log`回滚日志，事务回滚时能够撤销所有已经成功执行的`sql`语句
  - 持久性：指事务一旦提交它对数据库的改变就应该是永久性的，利用`Innodb`的`redo log`重做日志，当有一条记录要更新时，`InnoDB` 引擎就会先把记录写到 `redo log`，当数据库宕机重启的时候，会将`redo log`中的内容恢复到数据库中
  - 隔离性：并发执行的各个事务之间不能互相干扰，利用的是锁和`MVCC`机制
- 锁机制
  - 表级锁：对整张表枷锁
  - 行级锁：对当前操作的行加锁
- 排他锁：X写锁，数据被加上写锁，其他事务不能对该数据进行读和写
- 共享锁：S读锁，数据被加上读锁，允许其他事务对该数据进行读，不允许写
- 乐观锁：解决丢失更新问题，设置版本号
- 悲观锁：串行执行
- 数据库三级模式
  - 外模式：描述数据库用户可见的局部数据的逻辑结构和特征，是模式的子集
  - 模式：描述数据库中全体数据的逻辑结构和特征
  - 内模式：又称存储模式，描述数据库物理结构和存储方式
- 查询优化的策略
  - 如果子表达式多次出现，先将其计算结果保存起来，避免重复计算
  - 尽可能指明展示列，少用*代替
  - 避免在列索引上使用`IS NULL`和`IS NOT NULL`
- 视图：是从一个或多个表导出的虚拟的表，逻辑概念不占物空间，可以定义一个频繁使用的子查询
- 视图的作用：简化用户操作和语句，安全性、
- 存取控制：只授权给有资格的用户访问数据库的权限
- 游标：系统为用户开设的一个数据缓冲区，存放`SQL`语句的执行结果
- 数据库查询步骤
  - 查询分析：对查询语句进行词法分析、语法分析
  - 查询检查：对合法的查询语句进行语义检查
  - 查询优化：选择一个高效执行的查询处理策略
  - 查询执行





#### 软件工程

- 软件生命周期：问题定义、可行性分析、需求分析、开发阶段、维护
- 需求分析：简单来说就是确定系统要做什么
- 瀑布模型：根据生命周期，一步一步完成，以文档作为驱动、适合软件需求很明确的软件项目；优点：容易理解管理成本低；缺点：需要客户能够完整清晰表达需求、需求的错误可能在后期才能发现
- 增量模型：把一个软件开发生命周期当作一个增量，且一个增量均发布一个可操作产品；优点：可先发布部分核心功能给客户，能更好的应对需求的变化；缺点：管理发生的成本、进度的复杂性可能会超出组织的能力
- 喷泉模型：软件开发的各个阶段没有固定的前后关系和界限，编码不一定要在设计之后；缺点：需要大量开发人员，不利于项目管理，严格管理文档
- 黑盒测试：把被测软件看成一个黑盒子，只考虑输入输出，不考虑内部逻辑，
- 白盒测试：研究源代码和程序内部逻辑，语句覆盖、判定覆盖、 条件覆盖
- 软件维护：纠错性维护、适应性维护、完善性维护
- 面向对象：把事情看作一个个对象组成，对象之间相互联系，构成整个项目
- 面向过程：分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现
- `UML`中有哪些图：用例图（描述需求)、顺序图（模拟某个操作执行过程）、活动图、类图
- `CMM`（软件成熟能力度）等级：
- 初始级：工作无序，没有章法
  - 可重复级：管理制度化，建立了基本的管理制度和规章
- 已定义级：开发过程实现标准化文档化
  - 已管理级：建立了定量的质量目标。生产效率和质量可度量
  - 优化级：
- 





#### C/C++

- 堆：用于动态分配内存，由程序员手动创建和销毁
- 栈：存放局部变量、函数参数等，由编译器自动管理
- C中内存分区：堆、栈、代码区、全局/静态存储区、常量存储区
- C语言程序执行过程：`.C`文件经过预处理器变成`.i`文件，经过编译器变成`.s`文件，经过汇编器变成`.o`文件，最后经过连接器变成可执行文件
- `new`和`malloc`的区别：使用`new`操作符时无须指定内存块的大小，编译器会根据类型信息自行计算。而`malloc`则需要显式地指出所需内存的大小
- `const`
  - 作用：定义常量、防止修改增加程序健壮性、节省空间、
  - 用法
    - 定义常量
    - 结合指针使用
    - 函数种使用
    - 类中使用：任何不会修改数据成员的函数都应该声明为`const`类型
- `volatile`
  - `const` 可以是 `volatile` （如只读的状态寄存器）
  - `volatile` 关键字声明的变量，每次访问时都必须从内存中取出值
- 析构函数调用的次序：先派生类后基类
- 构造函数的调用次序：先基类后派生类
- 引用：变量的别名，必须进行初始化
- 重载：方法名相同，参数不同
- 重写：子类重写父类的方法
- 全局对象的构造函数会在`main` 函数之前执行
- 引用与指针的区别：
  - 引用必须被初始化，指针不用
  - 引用初始化后不能被改变
  - 不存在指向空值的引用
- 基类的析构函数必须是虚函数，否则派生类的析构函数用不上造成资源的泄露
- 操作系统和编译器如何区分全局变量和局部变量：根据内存的分配位置不同进行区分，全局变量存放在全局存储区，而局部变量存储在堆栈中





#### 程序设计

- 重点题：2020、2025、2034、2035、2036、2037、2041、2045、2047、2057、2067、2083
- 汉字占两个字节即两个`ASCII`码且小于0



#### 项目面试

- 项目中遇到的问题
- 你负责的模块
  - 物资管理
    - 数据库：物资表（名称、规格型号、分类、计算单位）、物资来源表（供应商信息）、入库信息表（时间、操作人员）、出库信息表
    - 主要工作：管理物资的出库入库，物资的统计，发放物资管理，库存管理
  - 疫情管理
    - 数据库：返乡申请表（村庄、返乡日期、交通工具）、健康记录表、健康打卡表
    - 主要工作：查看审批村民的返乡申请，批准或延迟返乡，统计返乡信息。管理村民的打卡信息设置14天打卡
- 角色：系统管理员、村民管理员、扶贫办公室、物资管理员、疫情防控部、村民







#### 离散数学

- 析取范式：有限个简单合取式的析取构成的公式

- 合取范式：有限个简单析取式的合取构成的公式

- 主析取范式：析取范式中所有简单合取式都是极小项

- 全称量词、存在量词

- 前束范式：量词全在公式前面

  

- 笛卡尔积：`AXB`表示集合A和集合B中各取一个元素构成的有序对的集合

- 二元关系：一个集合为空或者不为空且元素都是有序对

  - 关系的性质：自反、反自反、对称性、反对称性、传递性

- 闭包：添加尽可能少的有序对是关系满足某个性质，如自反闭包

- 等价关系：满足自反性、对称性、传递性的关系，如等于关系、同姓关系

- 偏序关系：满足自反性、反对称性、传递性的关系，如整除关系大于等于关系，用字符串比较函数`strcmp()`

- 代数系统：非空集合和集合上一元或二元运算组成的系统。如<N，+>、<R，+>

- 交换群（阿贝尔群）群：若代数系统中二元运算是可交换的则把代数系统称为半群

- 半群：若代数系统中二元运算是可结合的则把代数系统称为半群

- 幺半群（独异点）：半群中的二元运算存在单位元

- 群：独异点中每个元素都存在逆元，且逆元属于也该集合，如整数加群、有理数加群

- 环：包含两个二元运算的代数系统，一个运算满足交换律，一个运算满足结合律，并且两个运算满足分配律，如整数集的加法和乘法构成换

  

- 欧拉回路：通过图中所有边一次且仅一次行遍所有顶点的回路称作欧拉回路

- 欧拉图：具有欧拉回路的图

- 哈密顿回路：经过图中顶点一次且仅一次的回路

- 哈密顿图：具有哈密顿回路的图

- 欧拉公式：连通平面图的顶点数边数、面数满足：顶点数--边数+面数 = 2





#### 杭电复试

1. 密码学：加密算法、慢启动；
5. 密码学：AES（e.g.AES的圈变换的四个部分:字节代替，行移位，列混合，圈密钥加）
11. 离散数学：群的定义；